ID,Type,Context,Module,Subject,Description,Decision,Rationale,Timestamp
"mem-001","Decision","System","All","Query Interface Standardization","Các hàm query trong các crate nghiệp vụ (todo, architecture, memories) có signature không đồng nhất.","Tất cả các hàm `query` public trong các crate nghiệp vụ phải được tái cấu trúc để chấp nhận một tham số duy nhất: `repository::Query<Vec<u8>>`. Hàm `shared::filter` bị loại bỏ.","Tăng tính nhất quán và thanh lịch của kiến trúc. Giảm sự ghép nối giữa các crate. Tận dụng tối đa sự trừu tượng của `repository::Storage`. Đơn giản hóa việc sử dụng và bảo trì API.",2024-06-09T00:00:00Z
"mem-002","Decision","System","All","Single-Word Identifier Enforcement","Phát hiện nhiều định danh vi phạm quy tắc đơn từ trong code test, benchmark, và example.","Tái cấu trúc tất cả các định danh vi phạm (ví dụ: BenchStore -> Bench, temp_dir -> temp) để tuân thủ quy tắc đơn từ.","Duy trì tính nhất quán và kỷ luật của triết lý dự án. Tạo ra một codebase có phong cách độc đáo và rõ ràng theo quy ước đã định.",2024-06-09T00:00:00Z
"mem-003","Refactor","architecture","add","Simplifying `add` function logic","Hàm `add` trong `architecture` có logic upsert phức tạp.","Loại bỏ logic upsert khỏi hàm `add`. `add` chỉ chịu trách nhiệm thêm mới. Cập nhật được xử lý bởi hàm `change`.","Tuân thủ Nguyên lý Đơn trách nhiệm (SRP). Giảm độ phức tạp, tăng tính dễ đọc và dễ bảo trì.",2024-06-09T00:00:00Z
"mem-004","Refactor","memories","add","Timestamp generation","Hàm `add` trong `memories` yêu cầu người gọi truyền timestamp.","Hàm `add` sẽ tự động tạo timestamp bằng `repository::now()`.","Tăng tính nhất quán với các hàm `add` khác. Giảm gánh nặng cho người gọi API. Đảm bảo timestamp luôn hợp lệ.",2024-06-09T00:00:00Z
"mem-005","Decision","System","All","Hoàn thiện refactor, test, benchmark, enum, lint","Toàn bộ hệ thống đã hoàn thiện refactor, test, benchmark, enum, truyền kiểu, truy vấn, sạch lint, sạch warning, không còn nợ kỹ thuật.","Đồng bộ hóa mọi module, test, benchmark, ví dụ, enum, truyền kiểu, truy vấn, kiểm thử, chuẩn hóa tuyệt đối.","Sẵn sàng mở rộng, không còn nợ kỹ thuật, codebase đạt trạng thái thanh lịch, rõ ràng, dễ bảo trì.",2024-06-09T00:00:00Z
"mem-006","Decision","System","memories","Refactor 'memories' index for type safety and performance","The indexing strategy for memories relied on the first byte of a String 'type', causing collision/correctness risks and lacking type safety.","Refactor the 'memories' crate to use a dedicated 'Kind' enum for the record type. Implement conversions from the enum to a collision-free u8 for indexing. Update all related logic, including the index key structure to '[type_byte][rev_time][id]'.","This change eliminates data correctness bugs from key collisions. It introduces type safety, making the system more robust and easier to maintain. It aligns the architecture of 'memories' with the proven, high-performance design of the 'task' crate, reducing architectural debt.",2024-06-09T00:00:00Z
"mem-007","Decision","System","architecture","Refactor 'architecture' index for flexible querying and type safety","The current index for architecture records is a direct copy of the composite string key, which is inefficient for storage and disallows flexible querying (e.g., by type or module). The 'type' field is a raw String, risking data inconsistency.","Refactor the 'architecture' crate to: 1. Introduce a 'Kind' enum for the 'type' field with proper conversions. 2. Redesign the index key to a structured format: '[type_byte][context_bytes]\0[module_bytes]\0[name_bytes]'. This enables efficient, multi-level filtering.","This change significantly improves query performance and flexibility, allowing for targeted data retrieval without full index scans. It introduces type safety for architectural components, reducing architectural debt and aligning it with the robust design of the 'task' and 'memories' crates.",2024-06-09T00:00:00Z
"mem-008","Decision","System","All","CLI Entry Point Consolidation","Each business logic crate (task, memories, architecture) had its own binary entry point, leading to code duplication and a scattered user interface.","All individual binary entry points (`/bin/main.rs`) are removed from the `task`, `memories`, and `architecture` crates. The `knowledge` crate is now the single, unified CLI entry point for the entire system, acting as a facade.","This architectural change enforces the Single Responsibility Principle, making logic crates pure libraries. It simplifies the user experience, reduces maintenance overhead, and creates a clear boundary between the core logic and the application's user interface layer.",2024-06-09T00:00:00Z
"mem-009","Decision","System","knowledge","Standardize Facade API using Parameter Object pattern","The 'add' functions within the 'knowledge' facade crate had inconsistent signatures; some took a long list of parameters while others took a single struct. A redundant 'Patch' struct also existed in the 'shared' crate.","1. Refactor all 'add' functions in 'knowledge::{task, memories}' to accept a single 'Add' struct argument (Parameter Object). 2. Remove the obsolete 'Patch' struct from the 'shared' crate.","This refactoring significantly improves API consistency, readability, and maintainability across the facade layer. It eliminates a classic 'long parameter list' code smell and removes dead code, resulting in a cleaner and more elegant architecture.",2024-06-10T00:00:00Z
"mem-010","Decision","System","All","Implement a systematic input validation layer","The system lacked a consistent input validation mechanism, posing risks to data integrity, performance, and security (e.g., storing overly long strings).","Introduced a `validate()` method on all `Add` parameter objects within the `knowledge` facade. This method is called from the CLI handler in `main.rs` before passing data to the business logic layer. The generic `Error::Input` was replaced with a more descriptive `Error::Validation(String)`.","This change establishes a clear validation boundary, enhancing system robustness by ensuring all user input conforms to predefined rules (e.g., length limits). It improves security by preventing storage of potentially harmful or malformed data and provides more specific error feedback to the user.",2024-06-10T00:00:00Z
"mem-011","Decision","System","All","Implement a structured Interaction Layer using the Command pattern","Direct function calls from the UI to business logic lack a centralized point for control, auditing, and structured logging. This poses a risk to observability and makes implementing cross-cutting concerns difficult.","Replaced direct function calls with a Command pattern. A shared 'Interaction' struct now wraps all business logic 'Commands' (e.g., AddTask, AddMemory). This wrapper contains metadata like a unique ID and timestamp. Facade functions were refactored into 'Handlers' that process these Interactions, enabling structured logging and validation at a single entry point.","This architectural shift massively improves system observability and auditability by creating a structured, loggable record for every attempted action. It decouples the UI from the business logic and provides a consistent, reusable framework for handling all future commands, enhancing security and maintainability.",2024-06-10T00:00:00Z
"mem-012","Feature","repository","Tích hợp Metric vào Actor Model","Logic metric trong sled.rs không thể hoạt động vì các thao tác đã được chuyển vào actor.rs. Cần di chuyển logic đo lường vào đúng nơi nó cần thực thi: bên trong message loop của actor.","1. Thêm method record đồng bộ cho Registry metric để có thể gọi trong thread Actor mà không cần async runtime. 2. Tích hợp metric vào Actor message loop, ghi nhận cho tất cả 7 loại thao tác: insert, fetch, update, delete, query, mass, keys. 3. Sử dụng std::sync::RwLock thay vì async để tránh deadlock. 4. Test coverage hoàn chỉnh với concurrent access testing.","Tăng cường observability và monitoring cho hệ thống database. Cung cấp khả năng theo dõi hiệu suất và phát hiện vấn đề trong thời gian thực. Thread-safe và concurrent-ready, đảm bảo không ảnh hưởng đến hiệu suất của Actor pattern. Tuân thủ nguyên tắc Single Responsibility và không phá vỡ kiến trúc hiện tại.",2024-12-19T00:00:00Z